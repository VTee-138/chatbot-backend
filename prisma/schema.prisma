generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = "postgresql://n8n_user:n8n_pass@100.92.102.97:5432/ai_chatbot_db"
}

model User {
  id                        String                      @id @default(cuid())
  email                     String?                     @unique
  avatarUrl                 String?
  passwordHash              String?
  emailVerifiedAt           DateTime?
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime                    @updatedAt
  role                      Role                        @default(USER)
  twoFactorBackupCodes      String[]
  twoFactorEnabled          Boolean                     @default(false)
  twoFactorSecret           String?
  phoneNumber               String?
  userName                  String?                     @unique
  email_verification_tokens email_verification_tokens[]
  group_members             group_members[]
  groups                    groups[]
  invitations               invitations[]
  password_reset_tokens     password_reset_tokens[]
  sessions                  sessions[]
  ssoAccounts               ssoAccount[]

  @@map("users")
}

model ssoAccount {
  provider   String
  userId     String
  providerId String
  user       User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerId])
  @@map("sso_accounts")
}

model ai_usage_logs {
  id               String        @id
  modelName        String
  promptTokens     Int
  completionTokens Int
  totalTokens      Int
  cost             Float
  createdAt        DateTime      @default(now())
  groupId          String
  conversationId   String
  conversations    conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  groups           groups        @relation(fields: [groupId], references: [id], onDelete: Cascade)
}

model channels {
  id                String          @id
  name              String
  provider          ChannelProvider
  providerChannelId String
  groupId           String
  createdAt         DateTime        @default(now())
  updatedAt         DateTime
  status            ChannelStatus   @default(ACTIVE)
  groups            groups          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  conversations     conversations[]

  @@unique([provider, providerChannelId])
  @@index([groupId])
}

model contacts {
  id         String      @id
  type       ContactType
  value      String
  isPrimary  Boolean     @default(false)
  customerId String
  createdAt  DateTime    @default(now())
  customers  customers   @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([customerId, type, value])
}

model conversation_read_statuses {
  conversationId String
  groupMemberId  String
  readAt         DateTime      @default(now())
  conversations  conversations @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  group_members  group_members @relation(fields: [groupMemberId], references: [id], onDelete: Cascade)

  @@id([conversationId, groupMemberId])
}

model conversations {
  id                         String                       @id
  status                     ConversationStatus           @default(OPEN)
  groupId                    String
  channelId                  String
  customerId                 String
  assigneeId                 String?
  createdAt                  DateTime                     @default(now())
  updatedAt                  DateTime
  chatbotEnabled             Boolean                      @default(true)
  providerConversationId     String                       @unique
  lastMessageAt              DateTime                     @default(now())
  providerAdId               String?
  ai_usage_logs              ai_usage_logs[]
  conversation_read_statuses conversation_read_statuses[]
  group_members              group_members?               @relation(fields: [assigneeId], references: [id])
  channels                   channels                     @relation(fields: [channelId], references: [id], onDelete: Cascade)
  customers                  customers                    @relation(fields: [customerId], references: [id], onDelete: Cascade)
  groups                     groups                       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  messages                   messages[]

  @@index([assigneeId])
  @@index([groupId])
}

model credit_purchases {
  id             String   @id
  amount         Float
  cost           Float
  stripeChargeId String   @unique
  createdAt      DateTime @default(now())
  groupId        String
  groups         groups   @relation(fields: [groupId], references: [id], onDelete: Cascade)
}

model customer_identities {
  id                 String          @id
  provider           ChannelProvider
  providerCustomerId String
  customerId         String
  customers          customers       @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([provider, providerCustomerId])
}

model customers {
  id                  String                @id
  fullName            String
  avatarUrl           String?
  groupId             String
  createdAt           DateTime              @default(now())
  updatedAt           DateTime
  contacts            contacts[]
  conversations       conversations[]
  customer_identities customer_identities[]
  groups              groups                @relation(fields: [groupId], references: [id], onDelete: Cascade)
  notes               notes[]
  tags                tags[]                @relation("CustomerToTag")
}

model email_verification_tokens {
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String
  tokenHash String   @id @unique
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model group_members {
  id                         String                       @id
  role                       GroupRole                    @default(MEMBER)
  userId                     String
  groupId                    String
  createdAt                  DateTime                     @default(now())
  assignmentWeight           Int                          @default(0)
  canBeAssigned              Boolean                      @default(true)
  updatedAt                  DateTime
  conversation_read_statuses conversation_read_statuses[]
  conversations              conversations[]
  groups                     groups                       @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users                      User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  notes                      notes[]

  @@unique([userId, groupId])
}

model groups {
  id                String             @id
  name              String
  slug              String             @unique
  logoUrl           String?
  creatorId         String
  createdAt         DateTime           @default(now())
  updatedAt         DateTime
  autoAssignEnabled Boolean            @default(false)
  receptionMode     ReceptionMode      @default(MANUAL)
  creditBalance     Float              @default(0)
  countryCode       String?
  emailContact      String
  phoneContact      String
  ai_usage_logs     ai_usage_logs[]
  channels          channels[]
  conversations     conversations[]
  credit_purchases  credit_purchases[]
  customers         customers[]
  group_members     group_members[]
  Country           Country?           @relation(fields: [countryCode], references: [code])
  users             User               @relation(fields: [creatorId], references: [id])
  invitations       invitations[]
  subscriptions     subscriptions[]
  tags              tags[]
}

model invitations {
  id          String           @id
  email       String
  role        GroupRole
  token       String           @unique
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  groupId     String
  invitedById String
  createdAt   DateTime         @default(now())
  groups      groups           @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users       User             @relation(fields: [invitedById], references: [id], onDelete: Cascade)
}

model notes {
  id            String        @id
  content       String
  customerId    String
  authorId      String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime
  group_members group_members @relation(fields: [authorId], references: [id], onDelete: Cascade)
  customers     customers     @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model password_reset_tokens {
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String
  tokenHash String   @id @unique
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model plans {
  id                    String          @id
  type                  PlanType        @unique
  name                  String
  price                 Float
  maxGroups             Int
  maxMembersPerGroup    Int
  maxChannelsPerGroup   Int
  monthlyCreditsGranted Float           @default(0)
  stripePriceId         String?         @unique
  subscriptions         subscriptions[]
}

model sessions {
  id               String   @id @default(cuid())
  userId           String
  refreshTokenHash String   @unique
  expiresAt        DateTime
  userAgent        String?
  ipAddress        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime
  deviceId         String   @default(cuid())
  users            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model subscriptions {
  id                     String             @id
  groupId                String
  planId                 String
  stripeCustomerId       String?            @unique
  stripeSubscriptionId   String?            @unique
  stripeCurrentPeriodEnd DateTime?
  status                 SubscriptionStatus @default(ACTIVE)
  createdAt              DateTime           @default(now())
  updatedAt              DateTime
  groups                 groups             @relation(fields: [groupId], references: [id], onDelete: Cascade)
  plans                  plans              @relation(fields: [planId], references: [id])

  @@index([groupId])
}

model tags {
  id        String      @id
  name      String
  color     String?
  groupId   String
  groups    groups      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  customers customers[] @relation("CustomerToTag")

  @@unique([groupId, name])
}

model Country {
  code   String   @id
  name   String
  groups groups[]
}

model messages {
  id                    String                @id
  conversationId        String
  senderId              String?
  senderType            SenderType            @default(CUSTOMER)
  content               String                @db.Text
  messageType           MessageType           @default(TEXT)
  direction             Direction             @default(INCOMING)
  
  // Status tracking
  status                MessageStatus         @default(SENT)
  deliveredAt           DateTime?
  readAt                DateTime?
  
  // Provider-specific data
  providerMessageId     String?               @unique
  providerMetadata      Json?
  
  // Reply/Quote support
  replyToMessageId      String?
  replyToMessage        messages?             @relation("MessageReplies", fields: [replyToMessageId], references: [id], onDelete: SetNull)
  replies               messages[]            @relation("MessageReplies")
  
  // Error handling
  errorCode             String?
  errorMessage          String?
  retryCount            Int                   @default(0)
  
  // Timestamps
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  
  // Relations
  conversations         conversations         @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  message_attachments   message_attachments[]

  @@index([conversationId])
  @@index([createdAt])
  @@index([providerMessageId])
  @@index([senderId])
  @@index([conversationId, createdAt])
}

model zalo_oa_tokens {
  oa_id         String          @id @db.VarChar(255)
  access_token  String
  refresh_token String
  expires_at    DateTime        @db.Timestamptz(6)
  zalo_oa_users zalo_oa_users[]
}

model zalo_oa_users {
  id             Int            @id @default(autoincrement())
  oa_id          String         @db.VarChar(255)
  user_id        String
  zalo_oa_tokens zalo_oa_tokens @relation(fields: [oa_id], references: [oa_id], onDelete: NoAction, onUpdate: NoAction)
}

model message_attachments {
  id               String         @id
  messageId        String
  attachmentType   AttachmentType
  fileUrl          String
  fileName         String?
  fileSize         Int?
  mimeType         String?
  
  thumbnailUrl     String?
  width            Int?
  height           Int?
  duration         Int?
  
  providerFileId   String?
  providerMetadata Json?
  
  createdAt        DateTime       @default(now())
  
  messages         messages       @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([attachmentType])
}

enum Role {
  USER
  ADMIN
}

enum PlanType {
  FREE
  PLUS
  ENTERPRISE
}

enum ChannelProvider {
  FACEBOOK
  ZALO
  INSTAGRAM
  WEBSITE_LIVECHAT
}

enum ChannelStatus {
  ACTIVE
  INACTIVE
  PENDING
  ERROR
}

enum ContactType {
  EMAIL
  PHONE
}

enum ConversationStatus {
  OPEN
  CLOSED
  NEEDS_HUMAN_ATTENTION
}

enum GroupRole {
  ADMIN
  MEMBER
  OWNER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum ReceptionMode {
  MANUAL
  AI
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  AUDIO
  VIDEO
  STICKER
}

enum Direction {
  INCOMING
  OUTGOING
}

enum SenderType {
  CUSTOMER
  AGENT
  SYSTEM
  BOT
}

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum AttachmentType {
  IMAGE
  VIDEO
  AUDIO
  FILE
  STICKER
  LOCATION
  CONTACT
}
