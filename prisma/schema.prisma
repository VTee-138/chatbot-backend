generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String        @id @default(uuid())
  email                String?       @unique
  avatarUrl            String?       @map("avatar_url")
  passwordHash         String?       @map("password_hash")
  emailVerifiedAt      DateTime?     @map("email_verified_at")
  createdAt            DateTime      @default(now()) @map("created_at")
  updatedAt            DateTime?     @updatedAt @map("updated_at")
  role                 Role          @default(user)
  twoFactorBackupCodes String[]      @map("two_factor_backup_codes")
  twoFactorEnabled     Boolean       @default(false) @map("two_factor_enabled")
  twoFactorSecret      String?       @map("two_factor_secret")
  phoneNumber          String?       @map("phone_number")
  userName             String?       @unique @map("user_name")
  orders               Order[]
  payments             Payment[]
  groupMembers         GroupMember[]
  groups               Group[]
  ssoAccounts          SsoAccount[]

  @@map("users")
}

model SsoAccount {
  provider   String
  userId     String    @map("user_id")
  providerId String    @map("provider_id")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime? @updatedAt @map("updated_at")
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerId])
  @@map("sso_accounts")
}

model Plan {
  id            String         @id @default(uuid())
  name          String
  price         Int
  limits        Json
  type          PlanType
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime?      @updatedAt @map("updated_at")
  durationUnit  DurationUnit   @map("duration_unit")
  durationValue Int            @map("duration_value")
  subscriptions Subscription[]

  @@map("plans")
}

model Group {
  id                String         @id @default(uuid())
  name              String
  ownerId           String         @map("owner_id")
  autoAssignEnabled Boolean        @default(false) @map("auto_assign_enabled")
  aiModelCredits    Float          @default(0) @map("ai_model_credits")
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime?      @updatedAt @map("updated_at")
  deletedAt         DateTime?      @map("deleted_at")
  isActive          Boolean        @default(true) @map("is_active")
  aiUsageLog        AiUsageLog[]
  channels          Channel[]
  customers         Customer[]
  groupMembers      GroupMember[]
  users             User           @relation(fields: [ownerId], references: [id])
  subscriptions     Subscription[]

  @@unique([name, ownerId])
  @@map("groups")
}

model GroupMember {
  id               String           @id @default(uuid())
  role             GroupRole        @default(member)
  userId           String           @map("user_id")
  groupId          String           @map("group_id")
  status           InvitationStatus @default(accepted)
  assignmentWeight Int              @default(0) @map("assignment_weight")
  createdAt        DateTime         @default(now()) @map("created_at")
  updatedAt        DateTime?        @updatedAt @map("updated_at")
  Conversation     Conversation[]
  groups           Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("group_members")
}

model Subscription {
  id        String    @id @default(uuid())
  groupId   String    @map("group_id")
  planId    String    @map("plan_id")
  expireAt  DateTime? @map("expire_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime? @updatedAt @map("updated_at")
  startedAt DateTime? @map("start_at")
  groups    Group     @relation(fields: [groupId], references: [id])
  plans     Plan      @relation(fields: [planId], references: [id])

  @@index([groupId])
  @@map("subscriptions")
}

model Tag {
  id        String     @id @default(uuid())
  name      String
  color     String?
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime?  @updatedAt @map("updated_at")
  customers Customer[]

  @@map("tags")
}

model AiUsageLog {
  id             String       @id @default(uuid())
  modelName      String       @map("model_name")
  totalTokens    Int          @map("total_tokens")
  cost           Float
  createdAt      DateTime     @default(now()) @map("created_at")
  groupId        String       @map("group_id")
  conversationId String       @map("conversation_id")
  updatedAt      DateTime?    @updatedAt @map("updated_at")
  conversations  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  groups         Group        @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("ai_usage_logs")
}

model Channel {
  id           String          @id @default(uuid())
  name         String
  provider     ChannelProvider
  providerId   String          @map("provider_id")
  accessToken  String?         @map("access_token")
  refreshToken String?         @map("refresh_token")
  groupId      String          @map("group_id")
  createdAt    DateTime        @default(now()) @map("created_at")
  updatedAt    DateTime?       @updatedAt @map("updated_at")
  status       ChannelStatus   @default(active)
  expireAt     DateTime?       @map("expire_at")
  groups       Group           @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId, groupId])
  @@index([groupId])
  @@map("channels")
}

model Conversation {
  id                     String          @id @default(uuid())
  customerId             String          @unique @map("customer_id")
  assigneeId             String?         @map("assignee_id")
  createdAt              DateTime        @default(now()) @map("created_at")
  updatedAt              DateTime?       @updatedAt @map("updated_at")
  chatbotEnabled         Boolean         @default(true) @map("chatbot_enabled")
  providerConversationId String?         @unique @map("provider_conversation_id")
  lastMessageAt          DateTime        @default(now()) @map("last_message_at")
  providerAdId           String?         @map("provider_ad_id")
  providerCustomerId     String?         @map("provider_customer_id")
  provider               ChannelProvider
  providerId             String          @map("provider_id")
  aiUsageLog             AiUsageLog[]
  groupMembers           GroupMember?    @relation(fields: [assigneeId], references: [id])
  customers              Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)
  messages               Message[]

  @@index([assigneeId])
  @@map("conversations")
}

model Customer {
  id             String        @id @default(uuid())
  fullName       String?       @map("full_name")
  avatarUrl      String?       @map("avatar_url")
  phoneNumber    String?       @map("phone_number")
  email          String?
  identityNumber String?       @map("identity_number")
  address        String?
  dateOfBirth    DateTime?     @map("date_of_birth")
  gender         Gender?
  notes          String?
  groupId        String        @map("group_id")
  tagId          String?       @map("tag_id")
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime?     @updatedAt @map("updated_at")
  deletedAt      DateTime?     @map("deleted_at")
  conversations  Conversation?
  groups         Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  tags           Tag?          @relation(fields: [tagId], references: [id])

  @@index([groupId])
  @@index([email])
  @@index([phoneNumber])
  @@map("customers")
}

model Message {
  id                  String              @id @default(uuid())
  conversationId      String              @map("conversation_id")
  senderId            String?             @map("sender_id")
  senderType          SenderType          @map("sender_type")
  content             String
  messageType         MessageType         @default(text) @map("message_type")
  status              MessageStatus       @default(sent)
  deliveredAt         DateTime?           @map("delivered_at")
  readAt              DateTime?           @map("read_at")
  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime?           @updatedAt @map("updated_at")
  replyToMessageId    String?             @map("reply_to_message_id")
  providerMessageId   String              @map("provider_message_id")
  repliedToMessageId  String?             @map("replied_to_message_id")
  src                 Int                 @default(0)
  message_attachments MessageAttachment[]
  conversations       Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  replyToMessage      Message?            @relation("MessageReplies", fields: [replyToMessageId], references: [id])
  replies             Message[]           @relation("MessageReplies")

  @@map("messages")
}

model MessageAttachment {
  id               String         @id @default(uuid())
  messageId        String         @map("message_id")
  attachmentType   AttachmentType @map("attachment_type")
  fileUrl          String         @map("file_url")
  fileName         String?        @map("file_name")
  fileSize         Int?           @map("file_size")
  mimeType         String?        @map("mime_type")
  thumbnailUrl     String?        @map("thumbnail_url")
  width            Int?
  height           Int?
  duration         Int?
  providerFileId   String?        @map("provider_file_id")
  providerMetadata Json?          @map("provider_metadata")
  createdAt        DateTime       @default(now()) @map("created_at")
  updatedAt        DateTime?      @updatedAt @map("updated_at")
  messages         Message        @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
  @@index([attachmentType])
  @@map("message_attachments")
}

model Order {
  id        String      @id @default(uuid()) @map("id")
  orderCode String      @unique @map("order_code")
  userId    String      @map("user_id")
  amount    Decimal     @map("amount")
  status    OrderStatus @default(unpaid) @map("status")
  createdAt DateTime    @default(now()) @map("created_at")
  updatedAt DateTime?   @map("updated_at")
  deletedAt DateTime?   @map("deleted_at")
  data      Json?       @map("data")
  type      OrderType   @map("type")
  user      User        @relation(fields: [userId], references: [id])
  payments  Payment[]
}

model Payment {
  id              String        @id @default(uuid()) @map("id")
  orderId         String        @map("order_id")
  userId          String        @map("user_id")
  amount          Decimal       @map("amount")
  status          PaymentStatus @default(pending) @map("status")
  transactionId   String?       @map("transaction_id")
  createdAt       DateTime      @default(now()) @map("created_at")
  paymentProvider String?       @map("payment_provider")
  updatedAt       DateTime?     @updatedAt @map("updated_at")
  order           Order         @relation(fields: [orderId], references: [id])
  user            User          @relation(fields: [userId], references: [id])
}

enum Role {
  user
  admin
}

enum PlanType {
  personal
  groups
}

enum ChannelProvider {
  facebook
  zalo
  instagram
}

enum ChannelStatus {
  active
  inactive
  pending
  error
}

enum GroupRole {
  manager
  member
  owner
}

enum InvitationStatus {
  pending
  accepted
  declined
}

enum MessageType {
  text
  image
  file
  audio
  video
  sticker
  gif
  location
}

enum SenderType {
  human
  bot
}

enum MessageStatus {
  sent
  delivered
  read
  failed
}

enum AttachmentType {
  image
  video
  audio
  file
  sticker
  location
  contact
}

enum Gender {
  male
  female
  other
  prefer_not_to_say
}

enum PaymentStatus {
  pending
  success
  failed
  refunded
}

enum OrderStatus {
  unpaid
  paid
}

enum OrderType {
  group_creation
  plan_renewal
  credit_purchase
  plan_purchase
}

enum DurationUnit {
  day
  month
  year
}
