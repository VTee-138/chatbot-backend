generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String                      @id @default(uuid())
  email                     String?                     @unique
  avatarUrl                 String?
  passwordHash              String?
  emailVerifiedAt           DateTime?
  createdAt                 DateTime                    @default(now())
  updatedAt                 DateTime                    @updatedAt
  role                      Role                        @default(USER)
  twoFactorBackupCodes      String[]
  twoFactorEnabled          Boolean                     @default(false)
  twoFactorSecret           String?
  phoneNumber               String?
  userName                  String?                     @unique
  email_verification_tokens email_verification_tokens[]
  group_members             GroupMember[]
  groups                    Group[]
  invitations               invitations[]
  password_reset_tokens     password_reset_tokens[]
  sessions                  sessions[]
  sso_accounts              SsoAccount[]
  zalo_personal_accounts    zalo_personal_accounts[]

  @@map("users")
}

model SsoAccount {
  provider   String
  userId     String
  providerId String
  users      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerId])
  @@map("sso_accounts")
}

model Plan {
  id                    String         @id @default(uuid())
  type                  PlanType       @unique
  name                  String
  price                 Float
  maxGroups             Int
  maxMembersPerGroup    Int
  maxChannelsPerGroup   Int
  monthlyCreditsGranted Float          @default(0)
  stripePriceId         String?        @unique
  subscriptions         Subscription[]

  @@map("plans")
}

model Group {
  id                     String                   @id @default(uuid())
  name                   String
  slug                   String                   @unique
  logoUrl                String?
  creatorId              String
  createdAt              DateTime                 @default(now())
  updatedAt              DateTime
  autoAssignEnabled      Boolean                  @default(false)
  receptionMode          ReceptionMode            @default(MANUAL)
  creditBalance          Float                    @default(0)
  countryCode            String?
  emailContact           String
  phoneContact           String
  ai_usage_logs          AiUsageLog[]
  channels               Channel[]
  conversations          Conversation[]
  credit_purchases       credit_purchases[]
  customers              Customer[]
  group_members          GroupMember[]
  Country                Country?                 @relation(fields: [countryCode], references: [code])
  users                  User                     @relation(fields: [creatorId], references: [id])
  invitations            invitations[]
  subscriptions          Subscription[]
  tags                   Tag[]
  zalo_personal_accounts zalo_personal_accounts[]

  @@map("groups")
}

model GroupMember {
  id                         String                       @id @default(uuid())
  role                       GroupRole                    @default(MEMBER)
  userId                     String
  groupId                    String
  createdAt                  DateTime                     @default(now())
  assignmentWeight           Int                          @default(0)
  canBeAssigned              Boolean                      @default(true)
  updatedAt                  DateTime
  conversation_read_statuses conversation_read_statuses[]
  conversations              Conversation[]
  groups                     Group                        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users                      User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  notes                      notes[]

  @@unique([userId, groupId])
  @@map("group_members")
}

model Subscription {
  id                     String             @id @default(uuid())
  groupId                String
  planId                 String
  stripeCustomerId       String?            @unique
  stripeSubscriptionId   String?            @unique
  stripeCurrentPeriodEnd DateTime?
  status                 SubscriptionStatus @default(ACTIVE)
  createdAt              DateTime           @default(now())
  updatedAt              DateTime
  groups                 Group              @relation(fields: [groupId], references: [id], onDelete: Cascade)
  plans                  Plan               @relation(fields: [planId], references: [id])

  @@index([groupId])
  @@map("subscriptions")
}

model Tag {
  id        String     @id @default(uuid())
  name      String
  color     String?
  groupId   String
  groups    Group      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  customers Customer[] @relation("CustomerToTag")

  @@unique([groupId, name])
  @@map("tags")
}

model AiUsageLog {
  id               String       @id @default(uuid())
  modelName        String
  promptTokens     Int
  completionTokens Int
  totalTokens      Int
  cost             Float
  createdAt        DateTime     @default(now())
  groupId          String
  conversationId   String
  conversations    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  groups           Group        @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@map("ai_usage_logs")
}

model Channel {
  id                String          @id @default(uuid())
  name              String
  provider          ChannelProvider
  providerChannelId String
  groupId           String
  createdAt         DateTime        @default(now())
  updatedAt         DateTime
  status            ChannelStatus   @default(ACTIVE)
  groups            Group           @relation(fields: [groupId], references: [id], onDelete: Cascade)
  conversations     Conversation[]

  @@unique([provider, providerChannelId])
  @@index([groupId])
  @@map("channels")
}

model Conversation {
  id                         String                       @id @default(uuid())
  status                     ConversationStatus           @default(OPEN)
  groupId                    String
  channelId                  String
  customerId                 String
  assigneeId                 String?
  createdAt                  DateTime                     @default(now())
  updatedAt                  DateTime
  chatbotEnabled             Boolean                      @default(true)
  providerConversationId     String                       @unique
  lastMessageAt              DateTime                     @default(now())
  providerAdId               String?
  ai_usage_logs              AiUsageLog[]
  conversation_read_statuses conversation_read_statuses[]
  group_members              GroupMember?                 @relation(fields: [assigneeId], references: [id])
  channels                   Channel                      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  customers                  Customer                     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  groups                     Group                        @relation(fields: [groupId], references: [id], onDelete: Cascade)
  messages                   Message[]

  @@index([assigneeId])
  @@index([groupId])
  @@map("conversations")
}

model Customer {
  id                  String                @id @default(uuid())
  fullName            String
  avatarUrl           String?
  groupId             String
  createdAt           DateTime              @default(now())
  updatedAt           DateTime
  contacts            contacts[]
  conversations       Conversation[]
  customer_identities customer_identities[]
  groups              Group                 @relation(fields: [groupId], references: [id], onDelete: Cascade)
  notes               notes[]
  tags                Tag[]                 @relation("CustomerToTag")

  @@map("customers")
}

model Message {
  id                  String              @id @default(uuid())
  conversationId      String
  senderId            String?
  content             String
  messageType         MessageType         @default(TEXT)
  direction           Direction           @default(INCOMING)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime
  deliveredAt         DateTime?
  errorCode           String?
  errorMessage        String?
  providerMessageId   String?             @unique
  providerMetadata    Json?
  readAt              DateTime?
  replyToMessageId    String?
  retryCount          Int                 @default(0)
  senderType          SenderType          @default(CUSTOMER)
  status              MessageStatus       @default(SENT)
  message_attachments MessageAttachment[]
  conversations       Conversation        @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  messages            Message?            @relation("messagesTomessages", fields: [replyToMessageId], references: [id])
  other_messages      Message[]           @relation("messagesTomessages")

  @@index([conversationId, createdAt])
  @@index([conversationId])
  @@index([createdAt])
  @@index([providerMessageId])
  @@index([senderId])
  @@map("messages")
}

model MessageAttachment {
  id               String         @id @default(uuid())
  messageId        String
  attachmentType   AttachmentType
  fileUrl          String
  fileName         String?
  fileSize         Int?
  mimeType         String?
  thumbnailUrl     String?
  width            Int?
  height           Int?
  duration         Int?
  providerFileId   String?
  providerMetadata Json?
  createdAt        DateTime       @default(now())
  messages         Message        @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([attachmentType])
  @@index([messageId])
  @@map("message_attachments")
}

model Country {
  code   String  @id
  name   String
  groups Group[]
}

model contacts {
  id         String      @id
  type       ContactType
  value      String
  isPrimary  Boolean     @default(false)
  customerId String
  createdAt  DateTime    @default(now())
  customers  Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([customerId, type, value])
}

model conversation_read_statuses {
  conversationId String
  groupMemberId  String
  readAt         DateTime     @default(now())
  conversations  Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  group_members  GroupMember  @relation(fields: [groupMemberId], references: [id], onDelete: Cascade)

  @@id([conversationId, groupMemberId])
}

model credit_purchases {
  id             String   @id
  amount         Float
  cost           Float
  stripeChargeId String   @unique
  createdAt      DateTime @default(now())
  groupId        String
  groups         Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
}

model customer_identities {
  id                 String          @id
  provider           ChannelProvider
  providerCustomerId String
  customerId         String
  customers          Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@unique([provider, providerCustomerId])
}

model email_verification_tokens {
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String
  tokenHash String   @id @unique
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model invitations {
  id          String           @id
  email       String
  role        GroupRole
  token       String           @unique
  status      InvitationStatus @default(PENDING)
  expiresAt   DateTime
  groupId     String
  invitedById String
  createdAt   DateTime         @default(now())
  groups      Group            @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users       User             @relation(fields: [invitedById], references: [id], onDelete: Cascade)
}

model notes {
  id            String      @id
  content       String
  customerId    String
  authorId      String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime
  group_members GroupMember @relation(fields: [authorId], references: [id], onDelete: Cascade)
  customers     Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)
}

model password_reset_tokens {
  expiresAt DateTime
  createdAt DateTime @default(now())
  userId    String
  tokenHash String   @id @unique
  users     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model sessions {
  id               String   @id
  userId           String
  refreshTokenHash String   @unique
  expiresAt        DateTime
  userAgent        String?
  ipAddress        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime
  deviceId         String
  users            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model zalo_oa_tokens {
  oa_id         String          @id @db.VarChar(255)
  access_token  String
  refresh_token String
  expires_at    DateTime        @db.Timestamptz(6)
  zalo_oa_users zalo_oa_users[]
}

model zalo_oa_users {
  id             Int            @id @default(autoincrement())
  oa_id          String         @db.VarChar(255)
  user_id        String
  zalo_oa_tokens zalo_oa_tokens @relation(fields: [oa_id], references: [oa_id], onDelete: NoAction, onUpdate: NoAction)
}

model zalo_personal_accounts {
  id              String    @id
  groupId         String
  userId          String
  zaloUserId      String    @unique
  zaloDisplayName String?
  zaloAvatarUrl   String?
  zaloPhoneNumber String?
  cookies         Json?
  accessToken     String?
  refreshToken    String?
  encryptedData   String?
  lastLoginAt     DateTime?
  expiresAt       DateTime?
  isActive        Boolean   @default(true)
  deviceInfo      Json?
  metadata        Json?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime
  groups          Group     @relation(fields: [groupId], references: [id], onDelete: Cascade)
  users           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([zaloUserId])
}

enum Role {
  USER
  ADMIN
}

enum PlanType {
  FREE
  PLUS
  ENTERPRISE
}

enum ChannelProvider {
  FACEBOOK
  ZALO
  INSTAGRAM
  WEBSITE_LIVECHAT
}

enum ChannelStatus {
  ACTIVE
  INACTIVE
  PENDING
  ERROR
}

enum GroupRole {
  ADMIN
  MEMBER
  OWNER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  AUDIO
  VIDEO
  STICKER
}

enum SenderType {
  CUSTOMER
  AGENT
  SYSTEM
  BOT
}

enum MessageStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
}

enum AttachmentType {
  IMAGE
  VIDEO
  AUDIO
  FILE
  STICKER
  LOCATION
  CONTACT
}

enum ContactType {
  EMAIL
  PHONE
}

enum ConversationStatus {
  OPEN
  CLOSED
  NEEDS_HUMAN_ATTENTION
}

enum Direction {
  INCOMING
  OUTGOING
}

enum ReceptionMode {
  MANUAL
  AI
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
}
